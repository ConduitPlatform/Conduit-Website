# SDK Usage

Since the database is up, its SDK comes up with a bunch of operations you could use.
In order to explain the functionality of the database SDK, we're going to extend
the [movie tutorial](./tutorials/cinema_ticket_booking).<br />
To start operating on schemas, you need to create one first. Let's create a movie schema using the SDK.

## Schema creation

Create schema from adapter accepts a JSON schema as an argument, and it stores into the database.
Additional arguments are required such as:
- Schema name
- [Schema fields](./sdk_usage#schema-fields)
- [Schema model options](./sdk_usage#model-options)
- Owner module name // module that owns the module
- Collection name ( name of the collection)

### Schema fields
Schema fields represent the whole schema. Each field may have:

Name | Type | Description |
| ---- | ---- | ----------- |
| `type` | TYPE | Could be TYPE.(String,Number,Boolean etc.)|
| `required` | boolean | Indicates if a field is required. |
| `unique` | boolean | Indicates if a field is unique. |
| `select` | boolean | Indicates if a field could be retreived from a query. |
| `description` | string | Description of the field, |
| `default` | any | Default value of the field. |
| `enum` | enum values |  When a field  has enum values. |

Assume that we want to create a movie schema. A movie may have **title** , **genre**, **duration**, **director** , **description**  **for_adults** and surely an **_id** field.
So a possible schema could be this:

```ts title="Movie schema"
enum MoviesGenreEnum {
    THRILLER = "THRILLER",
    COMEDY = "COMEDY",
    ADVENTURE ="ADVENTURE",
    SCIENCE_FICTION = "SCIFI"
};

const schema = {
    _id: TYPE.ObjectId,
    name: {
        type: TYPE.String,
        unique: true,
        required: true,
    },
    director: {
        type: TYPE.String,
        required: true,
    },
    duration: {
      type: TYPE.Number
    },
    genre: {
        type: TYPE.String,
        enum: Object.values(MoviesGenreEnum),
        required: true,
    },
    description: {
        type: TYPE.String,
        required: false,
        unique: false,
    },
    releaseDate: TYPE.Date,
    createdAt: TYPE.Date,
    updatedAt: TYPE.Date,
}
```
### Model Options

There is another argument that createSchemaFromAdapter() needs, and it is called modelOptions.
Model options are objects that are stored in the database and contain some information about our schema.

Name | Type | Description |
| ---- | ---- | ----------- |
| `type` | TYPE | Could be TYPE.(String,Number,Boolean etc.)|
| `conduit.permissions` | object | Schema permissions |
| `conduit.persmissions.extendable` | boolean | Indicates if a schema could be extend after its creation. |
| `conduit.permissions.canCreate` | boolean | Indicates if a module can create documents of that schema. |
| `conduit.permissions.canModify` | boolean | Indicates if a module can modify documents of that schema. |
| `conduit.permissions.canDelete` | boolean | Indicates if a module can delete of that schema. |

A modelOptions object could be this:

```ts title="Model options object"
const modelOptions = {
  timestamps: true,
  conduit: {
    permissions: {
      extendable: true,
      canCreate: false,
      canModify: 'ExtensionOnly',
      canDelete: false,
    },
  },
} as const;
```

## Schema creation

The final step is to call the createSchemaFromAdapter() function.
```jsx title="Request"
await grpcSdk.database.createSchemaFromAdapter({
    name: "Movies",
    fields: schema,
    modelOptions: modelOptions,
    collectionName: "", // could be 'Movies' also
})
```

## Getting schemas

The functionality of list schemas is also available in grpc-sdk.Fetching registered schemas could be done
by invoking the **getSchemas()** method
In detail:

```ts title="Request"
await grpcSdk.database.getSchemas({})
```

In case of success, an array of schema documents will be returned to you.

## Delete schema

Deleting schemas could also be done by calling the SDK's deleteSchema() function. All you need is Schema's name.
Remember that conduit allows you to delete the schema's created documents as well.

```ts title="Request"
await grpcSdk.database.deleteSchema({
    name: "Movies",
    deleteData: true // could be also false
})
```


## Schema extensions

What about adding extra fields to system schemas? You can accomplish this by using **setSchemaExtension()**.
Existing schemas, such as User, EmailTemplate, Client, and so on, can be extended.
Extending the Conduit User schema is a great example of usage. <br />
Assume that the existing user schema does not account for your specific project's preferences. You can make changes to the existing schema.
You are free to include any field you want.<br />
Assume your goal is to add a field called **recoverEmail** which is used to recover an account if the initial email is misplaced or forgotten.

```jsx title="Request"
await grpcSdk.database.setSchemaExtension({
    schemaName: "Movies",
    extOwner: "database",
    extFields:  {
        recoverEmail: {
            type: "String",
            required: "false",
        }
    }
})
```

Now the User schema includes this new field called **recoverEmail**.

## Database Operations

Conduit models provide several static helper functions for CRUD operations.<br/>
Queries are structured Mongoose-like. To see Conduit's query language click [here](./operators).

### findOne
Suppose that we want to find a record with a specific id.

```ts title="Request"
await grpcSdk.database.findOne("Movies",{ _id: "somemovieid"})
```

### findMany
For instance if we want to fetch all Movies that have
duration greater than 1 hour.

```ts title="Request"
await grpcSdk.database.findMany("Movies", { duration: { $gt: 60 } })
```

### create

Create operation is very simple. Just invoke the **create()** function through database sdk and fill the
necessary fields for document creation.

```ts title="Request"
await grpcSdk.database
        .create("Movies",{
                title: "The hobbit.",
                duration: 165,
                genre: "SCIFI",
                description: "Tolkien rocks",
                director: "Peter Jackson",
                releaseDate: "13/12/2012"
        })
```

### createMany

```ts title="Request"
await this.grpcSdk.database.createMany("User",
        [{
            title: "The hobbit.",
            duration: 165,
            genre: "SCIFI",
            description: "Tolkien rocks",
            director: "Peter Jackson",
            releaseDate: "13/12/2012"
        },
        {
            title: "The Spiderman",
            duration: 200,
            genre: "SCIFI",
            description: "Marvel rocks",
            director: "Sam Raimi",
            releaseDate: "29/04/2002"
        }])
```


### updateMany
In case of updating many documents given some constraints then we can use updateMany() function.<br />
Movies id's have to be an array.

```ts title="Request"
const idArray = [movieid2,movieid2,movieid3];
await grpcSdk.database
    .updaeteMany("Movies",{ _id :{ $in: idArray } })
```

### deleteOne

The only thing we need is the document ID we want to delete.

```ts title="Request"
await grpcSdk.database
    .deleteOne("Movies",{ _id : id })
```

### deleteMany

Like updateMany we can use **deleteMany** to delete documents given some constraints.

```ts title="Request"
const idArray = [movieid2,movieid2,movieid3];
await grpcSdk.database
    .deleteMany("Movies",{ _id :{ $in: idArray } })
```

### countDocuments

Sometimes we only need to count how many documents exist with specific features.
For example, if we want to count how many movies are suitable only for.
**countDocuments()** should be used.<br />
An alternative but more complicated way of doing it is to use **findMany()** and calculate the length of the returned array.

```ts title="Request"
grpcSdk.database
    .countDocuments("Movies",{ genre: 'SCIFI' })
```
