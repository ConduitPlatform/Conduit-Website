# SDK Usage

Since database is up, its sdk comes up with a bunch of operations you could use.
To start playing with database you need to create a schema first. And **createSchemaFromAdapter()**
goes for it.

## Schema creation

Create schema from adapter accepts a JSON schema as an argument, and it stores into the database.
Additional arguments are required such as:
- Schema name
- [Schema fields](./sdk_usage#schema-fields)
- [Schema model options](./sdk_usage#model-options)
- Owner module name // module that owns the module
- Collection name ( name of the collection)

### Schema fields
Schema fields represent the whole schema. Each field may have:

Name | Type | Description |
| ---- | ---- | ----------- |
| `type` | TYPE | Could be TYPE.(String,Number,Boolean etc.)|
| `required` | boolean | Indicates if a field is required. |
| `unique` | boolean | Indicates if a field is unique. |
| `select` | boolean | Indicates if a field could be retreived from a query. |
| `description` | string | Description of the field, |
| `default` | any | Default value of the field. |
| `enum` | enum values |  When a field  has enum values. |

Assume that we want to create a movie schema. A movie may have **title** , **genre**, **duration**, **description**  **for_adults** and surely an **_id** field.
So a possible schema could be this:

```jsx title="Movie schema"
enum MoviesGenreEnum {
    THRILLER = "THRILLER",
    COMEDY = "COMEDY",
    ADVENTURE ="ADVENTURE",
    SCIENCE_FICTION = "SCIFI"
};

const schema = {
    _id: TYPE.ObjectId,
    title: {
        type: TYPE.String,
        unique: true,
        required: true,
    },
    title: {
        type: TYPE.String,
        unique: true,
        required: true,
    },
    duration: {
      type: TYPE.Number
    },
    genre: {
        type: TYPE.String,
        enum: Object.values(MoviesGenreEnum),
        required: true,
    },
    description: {
        type: TYPE.String,
        required: false,
        unique: false,
    },
    forAdults: {
        type: TYPE.Boolean,
        required: true,
    }
    createdAt: TYPE.Date,
    updatedAt: TYPE.Date,
}
```
### Model Options

There is another argument that createSchemaFromAdapter() needs, and it is called modelOptions.
Model options are objects that are stored in the database and contain some information about our schema.

Name | Type | Description |
| ---- | ---- | ----------- |
| `type` | TYPE | Could be TYPE.(String,Number,Boolean etc.)|
| `conduit.permissions` | object | Schema permissions |
| `conduit.persmissions.extendable` | boolean | Indicates if a schema could be extend after its creation. |
| `conduit.permissions.canCreate` | boolean | Indicates if a module can create documents of that schema. |
| `conduit.permissions.canModify` | boolean | Indicates if a module can modify documents of that schema. |
| `conduit.permissions.canDelete` | boolean | Indicates if a module can delete of that schema. |

A modelOptions object could be this:

```jsx title="Model options object"
const modelOptions = {
  timestamps: true,
  conduit: {
    permissions: {
      extendable: true,
      canCreate: false,
      canModify: 'ExtensionOnly',
      canDelete: false,
    },
  },
} as const;
```

## Schema creation

The final step is to call the createSchemaFromAdapter() function.
```jsx title="Create schema from adapter"
await this.grpcSdk.database.createSchemaFromAdapter({
    name: "Movies",
    fields: schema,
    modelOptions: modelOptions,
    collectionName: "", // could be 'Movies' also
})
.catch(e => {
    ConduitGrpcSdk.Logger.error(e);
})
```

## Getting schemas

The functionality of list schemas is also available in grpc-sdk.Fetching registered schemas could be done
by invoking the **getSchemas()** method
In detail:

```jsx title="Getting registereds schemas"
await this.grpcSdk.database.getSchemas({})
.catch(e => {
    ConduitGrpcSdk.Logger.error(e);
})
```

In case of success, an array of schema documents will be returned to you.

## Delete schema

Deleting schemas could also be done by calling the SDK's deleteSchema() function. All you need is Schema's name.
Remember that conduit allows you to delete the schema's created documents as well.

```jsx title="Getting registereds schemas"
await this.grpcSdk.database.deleteSchema({
    name: "someschemaname",
    deleteData: true // could be also false
})
.catch(e => {
    ConduitGrpcSdk.Logger.error(e);
})
```


## Schema extensions

What about adding extra fields to system schemas? You can accomplish this by using **setSchemaExtension()**.
Existing schemas, such as User, EmailTemplate, Client, and so on, can be extended.
Extending the Conduit User schema is a great example of usage. <br />
Assume that the existing user schema does not account for your specific project's preferences. You can make changes to the existing schema.
You are free to include any field you want.<br />
Assume your goal is to add a field called **recoverEmail** which is used to recover an account if the initial email is misplaced or forgotten.

```jsx title="Set schema extension"
await this.grpcSdk.database.setSchemaExtension({
    schemaName: "User",
    extOwner: "database",
    extFields:  {
        recoverEmail: {
            type: "String",
            required: "false",
        }
    }
})
.catch(e => {
    ConduitGrpcSdk.Logger.error(e);
})
```

Now the User schema includes this new field called **recoverEmail**.

## Database Operations

Conduit models provide several static helper functions for CRUD operations.<br/>
Queries are structured Mongoose-like. To see Conduit's query language click [here](./operators).

### findOne
Suppose that we want to find a record with a specific id.

```jsx title="Set schema extension"
const user = await this.grpcSdk.database
            .findOne("User",{ _id: "someuserid"})
            .catch(e => {
                ConduitGrpcSdk.Logger.error(e);
            });
```

### findMany
For instance if we want to fetch all Users which have
enabled the 2FA using phone method ,then a query would be this:

```jsx title="Finding many documents"
const users = await this.grpcSdk.database
                .findMany("User", { $and: [ { hasTwoFa: true},{ twoFaMethod: 'phone'} ] })
                .catch(e => {
                    ConduitGrpcSdk.Logger.error(e);
                });
```

### create

```jsx title="Create a document"
await this.grpcSdk.database
        .create("User",{
                email: "example@mail.com",
                password: "P@ssw0rD!@",
                isVerified: true // could also be false
        })
        .catch(e => {
            ConduitGrpcSdk.Logger.error(e);
        });
```

### createMany

```jsx title="Create many documents"
await this.grpcSdk.database.createMany("User",
        [{
            email: "example@mail.com",
            password: "P@ssw0rD!@",
            isVerified: true // could also be false
        },
        {
            email: "example1@mail.com",
            password: "P@ssw0rD!@12",
            isVerified: true
        }])
        .catch(e => {
            ConduitGrpcSdk.Logger.error(e);
        });
```


### updateMany
In case of updating many documents given some constraints then we can use updateMany() function.<br />
Consider that we want to disable two-factor authentication for all users whose ids are contained in some array.

```jsx title="Update many documents "
const idArray = [userid1,userid2,userid3];
await this.grpcSdk.database
    .updaeteMany("User",{ _id :{ $in: idArray } },{ hasTwoFa: false})
    .catch(e => {
        ConduitGrpcSdk.Logger.error(e);
    });
```

### deleteOne

The only thing we need is the document ID we want to delete.

```jsx title="Update many documents "
await this.grpcSdk.database
    .deleteOne("User",{ _id : id })
    .catch(e => {
        ConduitGrpcSdk.Logger.error(e);
    });
```

### deleteMany

Like updateMany we can use **deleteMany** to delete documents given some constraints.

```jsx title="Delete many documents "
const idArray = [userid1,userid2,userid3];
await this.grpcSdk.database
    .deleteMany("User",{ _id :{ $in: idArray } })
    .catch(e => {
        ConduitGrpcSdk.Logger.error(e);
    });
```

### countDocuments

Sometimes we only need to count how many documents exist with specific features.
For example, if we want to count how many users have two-factor authentication enabled,
**countDocuments()** should be used.<br />
An alternative but more complicated way of doing it is to use **findMany()** and calculate the length of the returned array.

```jsx title="Cunt documents"
await this.grpcSdk.database
    .countDocuments("User",{ hasTwoFa: true })
    .catch(e => {
        ConduitGrpcSdk.Logger.error(e);
    });
```
